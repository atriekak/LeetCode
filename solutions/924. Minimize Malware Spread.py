from collections import deque
​
class Solution:
    #Solution 1
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        #Approach: DFS // color-coding connected components
        #Time Complexity: O(n^2)
        #Space Complexity: O(n)
        #where, n is the number of nodes in the graph
        
        self.colors = [-1 for _ in graph]     # -1 implies no coding yet
        col = 0
        
        for i in range(len(self.colors)):
            if self.colors[i] == -1:
                self.dfs(i, graph, col)
                col += 1
        
        szCluster = [0 for _ in range(col)]
        for c in self.colors:
            szCluster[c] += 1
            
        initCluster = [0 for _ in range(col)]
        for node in initial:
            initCluster[self.colors[node]] += 1
            
        result = None
        saved = 0
        for node in initial:
            #can only save a cluster if no more than one node is infected
            if initCluster[self.colors[node]] == 1:
                if szCluster[self.colors[node]] > saved:
                    saved = szCluster[self.colors[node]]
                    result = node
                elif szCluster[self.colors[node]] == saved:
                    result = min(result, node)
        
        if not result:
            result = inf
            for node in initial:
                result = min(result, node)
                
        return result
    
    def dfs(self, idx, graph, col):
        #base
        if self.colors[idx] != -1:
            return
        
        #logic
        self.colors[idx] = col
        for j in range(len(graph[idx])):
            if graph[idx][j] == 1:
                self.dfs(j, graph, col)
    
    #Solution 2
    """
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        #Approach: BFS // color-coding connected components
        #Time Complexity: O(n^2)
        #Space Complexity: O(n)
        #where, n is the number of nodes in the graph
        
        colors = [-1 for _ in graph]     # -1 implies no coding yet
        col = 0
        
        for i in range(len(colors)):
            if colors[i] == -1:
                de = deque()
                de.append(i)
                colors[i] = col
                
                while de:
                    popped = de.popleft()
                    for j in range(len(graph[popped])):
                        if graph[popped][j] == 1 and colors[j] == -1:
                            de.append(j)
                            colors[j] = col
                
                col += 1
        
